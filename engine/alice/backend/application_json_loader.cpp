/*
Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.

NVIDIA CORPORATION and its licensors retain all intellectual property
and proprietary rights in and to this software, related documentation
and any modifications thereto. Any use, reproduction, disclosure or
distribution of this software and related documentation without an express
license agreement from NVIDIA CORPORATION is strictly prohibited.
*/
#include "application_json_loader.hpp"

#include <unistd.h>

#include <fstream>
#include <memory>
#include <regex>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

#include "engine/alice/application.hpp"
#include "engine/alice/backend/backend.hpp"
#include "engine/alice/backend/config_backend.hpp"
#include "engine/alice/backend/message_ledger_backend.hpp"
#include "engine/alice/backend/names.hpp"
#include "engine/alice/backend/node_backend.hpp"
#include "engine/core/assert.hpp"
#include "engine/gems/serialization/json.hpp"

namespace isaac {
namespace alice {

namespace {

// Replaces occurences of `$(fullname XXX)` with `node_prefix + "XXX"` in any string occuring
// in the given JSON object.
void ExpandFullnames(const std::string& node_prefix, Json& json) {
  if (!json.is_object() && !json.is_array()) {
    return;
  }
  // Capture 3 groups:
  // First group is '$(fullname '.
  // Second group is the my_node_name, e.g., 'lqr' or 'joystick'.
  // Third group is the closing bracket ')'.
  const std::regex re("(\\$\\(fullname )(.*)(\\))");
  for (auto it = json.begin(); it != json.end(); ++it) {
    ExpandFullnames(node_prefix, *it);
    if (it->is_string()) {
      const std::string old_value = *it;
      // Second group, i.e. $2, captures the node name. Please see the definition of re above.
      const std::string new_value = std::regex_replace(old_value, re, node_prefix + "$2");
      // If value has changed, update json
      if (new_value != old_value) {
        *it = new_value;
      }
    }
  }
}

}  // namespace

ApplicationJsonLoader::ApplicationJsonLoader(const std::string& asset_path)
    : level_(0) {
  // Either use given asset path, or use current path.
  if (asset_path.empty()) {
    char* buffer = getcwd(nullptr, 0);
    asset_path_ = std::string(buffer);
    std::free(buffer);
  } else {
    asset_path_ = asset_path;
  }
}

std::string ApplicationJsonLoader::getAssetPath(const std::string& path) const {
  // Do nothing about absolute path
  if (!path.empty() && path.at(0) == '/') {
    return path;
  }
  return asset_path_ + "/" + path;
}

void ApplicationJsonLoader::loadApp(const nlohmann::json& json) {
  // Get valid application name
  const auto it_name = json.find("name");
  ASSERT(it_name != json.end(), "App JSON must have a name");
  const std::string app_name = *it_name;
  AssertValidName(app_name);
  name_ = app_name;

  // Scheduler config
  const auto it_scheduler = json.find("scheduler");
  if (it_scheduler != json.end()) {
    scheduler_json_ = *it_scheduler;
  } else {
    LOG_WARNING(
        "This application does not have an explicit scheduler configuration. "
        "One will be autogenerated to the best of the system's abilities if possible.");
    scheduler_json_ = {};
  }

  // Save two parameters which we need when the application shuts down
  const auto it_config_backup = json.find("config_backup");
  if (it_config_backup != json.end()) {
    config_backup_ = *it_config_backup;
  }
  const auto it_performance_report_out = json.find("performance_report_out");
  if (it_performance_report_out != json.end()) {
    performance_report_out_ = *it_performance_report_out;
  }
  const auto it_minidump_path = json.find("minidump_path");
  if (it_minidump_path != json.end()) {
    minidump_path_ = *it_minidump_path;
  }

  // the rest will happen via normal loading
  loadMore(json);
}

void ApplicationJsonLoader::loadMore(const nlohmann::json& json) {
  ASSERT(!json.is_null(), "Invalid JSON object");

  // modules
  const auto it_modules = json.find("modules");
  if (it_modules != json.end()) {
    std::vector<std::string> more_modules = *it_modules;
    modules_.insert(modules_.end(), more_modules.begin(), more_modules.end());
  }

  // Load config
  const auto it_config = json.find("config");
  if (it_config != json.end()) {
    loadConfig(*it_config);
  }

  // Load config files
  const auto it_config_files = json.find("config_files");
  if (it_config_files != json.end()) {
    for (const auto& config_file : *it_config_files) {
      loadConfigFromFile(config_file);
    }
  }

  // Load graph
  const auto it_graph = json.find("graph");
  if (it_graph != json.end()) {
    loadGraph(*it_graph);
  }

  // Load graph files
  const auto it_graph_files = json.find("graph_files");
  if (it_graph_files != json.end()) {
    for (const auto& graph_file : *it_graph_files) {
      loadGraphFromFile(graph_file);
    }
  }

  if (it_modules == json.end() && it_config == json.end() && it_config_files == json.end()
      && it_graph == json.end() && it_graph_files == json.end()) {
    LOG_ERROR("The Isaac app file did not contain any modules, config, or graph.");
  }
}

void ApplicationJsonLoader::appendModulePaths(const std::vector<std::string>& module_paths) {
  module_paths_.insert(module_paths_.end(), module_paths.begin(), module_paths.end());
}

void ApplicationJsonLoader::loadConfig(const nlohmann::json& json, const std::string& node_prefix) {
  // Add prefix to node names.
  nlohmann::json copy;
  for (auto it = json.begin(); it != json.end(); ++it) {
    copy[node_prefix + it.key()] = *it;
  }
  // Expand '$(fullname <name>)' by appending prefix
  ExpandFullnames(node_prefix, copy);
  // merge by overwriting with new
  if (level_ >= config_by_level_.size()) {
    config_by_level_.resize(level_ + 1);
  }
  auto& config = config_by_level_[level_];
  config = serialization::MergeJson(config, copy);
}

void ApplicationJsonLoader::loadConfigFromFile(const std::string& filename) {
  loadConfig(serialization::LoadJsonFromFile(getAssetPath(filename)));
}

void ApplicationJsonLoader::loadConfigFromText(const std::string& text) {
  loadConfig(serialization::LoadJsonFromText(text));
}

void ApplicationJsonLoader::loadGraph(const nlohmann::json& json, const std::string& node_prefix) {
  level_ = 0;
  loadGraphRecursive(json, node_prefix);
  level_ = 0;
}

void ApplicationJsonLoader::loadGraphRecursive(const nlohmann::json& json,
                                               const std::string& node_prefix) {
  level_++;
  ASSERT(!json.is_null(), "Graph JSON must not be NULL");
  auto nodes_it = json.find("nodes");
  ASSERT(nodes_it != json.end(), "The `nodes` section is mandatory in the graph JSON");
  ASSERT(nodes_it->is_array(), "`nodes` JSON must be an array: %s", nodes_it->dump(2).c_str());
  for (auto it = nodes_it->begin(); it != nodes_it->end(); ++it) {
    const auto& json = *it;
    auto maybe_subgraph = serialization::TryGetFromMap<std::string>(json, "subgraph");
    if (maybe_subgraph) {
      auto maybe_name = serialization::TryGetFromMap<std::string>(json, "name");
      ASSERT(maybe_name, "Missing mandatory field 'name' (type string) for node");
      const std::string nested_node_prefix = node_prefix + *maybe_name + ".";
      const std::string actual_subgraph_filename = getAssetPath(*maybe_subgraph);
      auto maybe_group_json = serialization::TryLoadJsonFromFile(actual_subgraph_filename);
      ASSERT(maybe_group_json, "Could not load subgraph from file '%s' (originally: '%s')",
             actual_subgraph_filename.c_str(), maybe_subgraph->c_str());
      // Load modules
      auto maybe_modules = serialization::TryGetFromMap<std::vector<std::string>>(
          *maybe_group_json, "modules");
      if (maybe_modules) {
        if (!maybe_modules->empty()) {
          // Only add modules which where not already loaded and create a smart info message.
          std::string text;
          for (size_t i = 0; i < maybe_modules->size(); i++) {
            const std::string& name = (*maybe_modules)[i];
            const bool is_new = std::find(modules_.begin(), modules_.end(), name) == modules_.end();
            if (is_new) {
              text += name;
              modules_.push_back(name);
            } else {
              text += "(" + name + ")";
            }
            if (i + 1 < modules_.size()) {
              text += ", ";
            }
          }
          LOG_INFO("Modules requested by subgraph '%s': %s", maybe_name->c_str(),
                   text.c_str());
        }
      } else {
        // TODO Check automatically if modules are missing via component namespace.
        LOG_WARNING("Loaded a subgraph with no modules section. Did you forget to add one?");
      }
      // Load config
      auto group_config = maybe_group_json->find("config");
      if (group_config != maybe_group_json->end()) {
        loadConfig(*group_config, nested_node_prefix);
      } else {
        LOG_WARNING("Loaded a subgraph with no config section. Did you forget to add one?");
      }
      // Load graph
      auto group_graph = maybe_group_json->find("graph");
      if (group_graph != maybe_group_json->end()) {
        loadGraphRecursive(*group_graph, nested_node_prefix);
      } else {
        LOG_WARNING("Loaded a subgraph with no graph section. Did you forget to add one?");
      }
    } else {
      nodes_.emplace_back(NodeJson{node_prefix, json});
    }
  }
  // setup connections:
  // "edges": [ {"source": "node/component/channel", "target": "node/component/channel"}, ... ]
  auto edges_it = json.find("edges");
  if (edges_it == json.end()) return;
  const nlohmann::json& edges = *edges_it;
  for (auto it = edges.begin(); it != edges.end(); ++it) {
    auto maybe_source = serialization::TryGetFromMap<std::string>(*it, "source");
    ASSERT(maybe_source, "Missing mandatory field `source` (type string) for edge");
    auto maybe_target = serialization::TryGetFromMap<std::string>(*it, "target");
    ASSERT(maybe_target, "Missing mandatory field `target` (type string) for edge");

    // Instead of connecting edges here, cache them since associated nodes may not be loaded yet.
    // We read all graphs first to get all the nodes. We'll connect edges before starting the
    // application.
    edges_.emplace_back(EdgeJson{node_prefix + *maybe_source, node_prefix + *maybe_target});
  }
  level_--;
}

void ApplicationJsonLoader::loadGraphFromFile(const std::string& filename) {
  loadGraph(serialization::LoadJsonFromFile(getAssetPath(filename)));
}

void ApplicationJsonLoader::loadGraphFromText(const std::string& text) {
  loadGraph(serialization::LoadJsonFromText(text));
}

nlohmann::json ApplicationJsonLoader::GetGraphJson(Application& app) {
  nlohmann::json graph;
  graph["nodes"] = app.backend()->node_backend()->saveToJson();
  nlohmann::json edges_json = nlohmann::json::array();
  for (const auto& connection : app.backend()->message_ledger_backend()->connections()) {
    edges_json.push_back({{"source", connection.source}, {"target", connection.target}});
  }
  graph["edges"] = std::move(edges_json);
  return graph;
}

bool ApplicationJsonLoader::WriteConfigToFile(const std::string& filename, const Json& json) {
  std::ofstream ofs(filename);
  if (!ofs) {
    LOG_ERROR("Error opening file '%s'", filename.c_str());
    return false;
  }
  // Serialize graph JSON to text so that we can filter what we don't need
  const std::string text = json.dump(2);
  // Create a filter which removes `__type_name` key/value pairs and all empty dictionaries
  auto filter = [](int depth, auto event, Json& parsed) {
    if (parsed.is_string() && parsed == "__type_name") return false;
    if (parsed.is_object() && parsed.empty()) return false;
    return true;
  };
  // Filter JSON by parsing it again with the filter callback and then dump it to file
  ofs << Json::parse(text, filter, false).dump(2);
  return true;
}

nlohmann::json ApplicationJsonLoader::GraphToJson(const std::vector<Component*>& components) {
  nlohmann::json node_json;
  nlohmann::json component_list_json;
  for (Component* component : components) {
    nlohmann::json component_json;
    component_json["name"] = component->name();
    component_json["type"] = component->type_name();
    component_list_json.emplace_back(std::move(component_json));
  }
  node_json["components"] = std::move(component_list_json);
  return node_json;
}

nlohmann::json ApplicationJsonLoader::ConfigToJson(const std::vector<Component*>& components) {
  Json config_json;
  for (Component* component : components) {
    config_json[component->node()->name()][component->name()] =
        component->node()->config().getAll(component);
  }
  return config_json;
}

}  // namespace alice
}  // namespace isaac
